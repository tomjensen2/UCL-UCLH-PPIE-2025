<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-touch-fullscreen" content="yes" />
  <title>Calcium Cascade ‚Äì Missile Command Mode</title>
  <style>
    :root {
      --bg1:#1e3c72; --bg2:#2a5298; --accent:#4fc3f7; --ok:#81c784; --warn:#ffd54f; --bad:#ef5350;
    }
    *{box-sizing:border-box}
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:#fff;overflow:hidden;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent}
    .container{display:flex;height:100vh;height:100dvh}
    .controls{width:320px;background:rgba(0,0,0,.8);padding:18px;overflow-y:auto;backdrop-filter:blur(10px)}
    .simulation-area{flex:1;position:relative;background:#000}
    h1{margin:0 0 12px 0;font-size:18px;color:var(--accent)}
    .control-group{margin-bottom:16px;padding:12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);border-radius:10px}
    .control-group h3{margin:0 0 8px 0;font-size:14px;color:var(--ok)}
    label{display:block;margin:6px 0 4px 0;font-size:12px;color:#ddd}
    input[type="text"],select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.1);color:#fff}
    button{padding:10px 14px;margin:6px 6px 0 0;background:linear-gradient(45deg,#4fc3f7,#29b6f6);border:none;border-radius:8px;color:white;cursor:pointer;font-size:14px;font-weight:600;min-height:40px}
    button.alt{background:linear-gradient(45deg,#ff9800,#f57c00)}
    button.danger{background:linear-gradient(45deg,#ef5350,#e53935)}
    button.secondary{background:linear-gradient(45deg,#607d8b,#455a64)}
    .row{display:flex;gap:8px}
    .row>*{flex:1}
    .status{position:absolute;top:12px;left:12px;background:rgba(0,0,0,.6);padding:10px 12px;border-radius:10px;font-size:12px}
    .status .meter{width:220px;height:10px;background:#222;border-radius:6px;overflow:hidden;margin-top:6px}
    .status .meter>div{height:100%;background:linear-gradient(90deg,#66bb6a,#ffee58,#ef5350);width:0%}
    canvas{border:2px solid rgba(255,255,255,.25);cursor:crosshair}
    .legend{position:absolute;bottom:12px;left:12px;background:rgba(0,0,0,.6);padding:10px 12px;border-radius:10px;font-size:11px}
    .board{display:grid;grid-template-columns:1fr auto;gap:6px;margin-top:8px}
    .board div{padding:6px 8px;background:rgba(255,255,255,.06);border-radius:6px}
    .small{font-size:11px;opacity:.9}
    @media (max-width:1024px){.container{flex-direction:column}.controls{width:100%;height:32vh}.simulation-area{height:68vh}}
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <h1>üß† Calcium Cascade ‚Äì Missile Command</h1>

      <div class="control-group">
        <h3>Player</h3>
        <label for="playerName">Name</label>
        <input id="playerName" type="text" placeholder="e.g., Ada" maxlength="16" />
        <div class="row">
          <button id="startBtn">Start Wave ‚ñ∂</button>
          <button id="resetBtn" class="alt">Reset üîÑ</button>
        </div>
      </div>

      <div class="control-group">
        <h3>Leaderboard (Local)</h3>
        <div id="leaderboard" class="board"></div>
        <div class="row">
          <button id="saveScoreBtn" class="secondary">Save Score üíæ</button>
          <button id="clearBoardBtn" class="danger">Clear Board üßπ</button>
        </div>
        <div class="small">Scores are stored in your browser (localStorage).</div>
      </div>

      <div class="control-group">
        <h3>Tips</h3>
        <div class="small">‚Ä¢ Click to fire a Ca¬≤‚Å∫ shot that travels and detonates.<br/>‚Ä¢ Keep the excitability bar low by suppressing glutamate near synapses.<br/>‚Ä¢ Chain CICR for bigger suppression!<br/>‚Ä¢ Ammo is limited per wave.</div>
      </div>
    </div>

    <div class="simulation-area">
      <canvas id="canvas" width="1280" height="800"></canvas>
      <div class="status">
        <div><strong>Wave:</strong> <span id="uiWave">1</span> &nbsp;‚Ä¢&nbsp; <strong>Score:</strong> <span id="uiScore">0</span> &nbsp;‚Ä¢&nbsp; <strong>Ammo:</strong> <span id="uiAmmo">0</span></div>
        <div style="margin-top:6px"><strong>Excitability</strong></div>
        <div class="meter"><div id="excMeter"></div></div>
        <div class="small" id="uiDebug"></div>
      </div>
      <div class="legend small">
        Axons = orange lines ‚Ä¢ Spikes = white/orange/red pulses ‚Ä¢ Synapses = white dots ‚Ä¢ Glutamate = background color zones (blue‚Üípurple‚Üíred) ‚Ä¢ Ca¬≤‚Å∫ = yellow‚Üíorange‚Üíred ‚Ä¢ Ca shots = teal trails
      </div>
    </div>
  </div>

  <script>
    // ----------------- Simulation constants -----------------
    const params = {
      diffusionRate: 1.1, decayRate: 0.035, erRelease: 0.85, ip3Threshold: 0.55,
      spontaneousRate: 0.001, hemichannelStrength: 0.4, cicrSensitivity: 0.9,
      cicrThreshold: 0.42, simSpeed: 1.0, mgluR: 1.0, atpSens: 1.0
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // World view
    let zoomLevel = 1.0, panX = 0, panY = 0;

    // Game state
    let running = false;
    let wave = 1;
    let score = 0;
    let ammo = 0;
    let bestExcitability = Infinity;
    let waveStartTime = 0;
    let waveDuration = 30; // seconds per wave

    // Missile Command mode systems
    const AXON_COUNT = 5;
    const SYNAPSE_SPACING = 110;
    const SPIKE_BASE_RATE = 0.45;
    const SPIKE_SPEED = 320;
    const SHOT_SPEED = 700;
    const SHOT_BLAST_IP3 = 1.2;
    const SHOT_BLAST_CA = 0.8;
    const SHOT_COOLDOWN = 0.45;
    const SHOT_AMMO_PER_WAVE = 8; // Increased base ammo to account for lose conditions
    const SPIKE_EFFECT_R = 26;
    const K_RELEASE = 0.085;
    const TAU_UPTAKE = 1.8;
    const UPTAKE_GAIN = 2.7;
    const CA_THETA = 0.45, CA_SLOPE = 0.16;
    const EXCIT_THRESH = 80;
    const LOSE_HOLD = 1.5;

    // Structures
    let astrocyte = null;
    let axons = [];
    let synapses = [];
    let spikes = [];
    let shots = [];
    let lastStamp = 0;
    let aboveTime = 0;
    let shotTimer = 0;

    // Leaderboard
    const BOARD_KEY = 'cc_leaderboard_v2';

    // -------------------- Geometry helpers --------------------
    function worldToScreen(x,y){return {x: x*zoomLevel+panX, y: y*zoomLevel+panY}}
    function screenToWorld(x,y){return {x: (x-panX)/zoomLevel, y: (y-panY)/zoomLevel}}
    function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
    const sigmoid = z => 1/(1+Math.exp(-z));

    // -------------------- Astrocyte Structure --------------------
    class AstrocyteStructure{
      constructor(cx,cy,size){ 
        this.centerX=cx; this.centerY=cy; this.size=size; 
        this.branches=[]; this.nodes=new Map(); this.ip3=new Map(); 
        this.generate(); 
      }
      
      generate(){
        this.branches=[]; this.nodes.clear(); this.ip3.clear();
        const primaryLen=75, branchLevels=4, processWidth=4, branchAngle=40*Math.PI/180; // Shorter, wider angles
        this.branches.push({x1:this.centerX,y1:this.centerY,x2:this.centerX,y2:this.centerY,width:this.size/4,type:'soma'});
        const primary=10; // Even more primary branches for coverage
        for(let i=0;i<primary;i++){ 
          const a=i/primary*2*Math.PI; 
          this._branch(this.centerX,this.centerY,a,primaryLen,branchLevels,processWidth,0,branchAngle); 
        }
        this._makeNodes();
      }
      
      _branch(x,y,ang,len,levels,width,level,branchAngle){ 
        if(levels<=0) return; 
        const ex=x+Math.cos(ang)*len, ey=y+Math.sin(ang)*len; 
        this.branches.push({x1:x,y1:y,x2:ex,y2:ey,width,type:levels===1?'endfoot':'process'});
        if(levels>1){ 
          const num = Math.random()>0.3?2:3; 
          for(let i=0;i<num;i++){ 
            const sa=ang+(i-(num-1)/2)*branchAngle+(Math.random()-0.5)*0.25; 
            this._branch(ex,ey,sa,len*0.72*(0.85+Math.random()*0.3),levels-1,Math.max(1,width*0.82),level+1,branchAngle); 
          } 
        }
      }
      
      _makeNodes(){ 
        const spacing=5, used=new Set(); // Denser node spacing for better coverage
        this.branches.forEach(b=>{ 
          const dx=b.x2-b.x1, dy=b.y2-b.y1; 
          const L=Math.hypot(dx,dy); 
          const n=Math.max(1,Math.floor(L/spacing)); 
          for(let i=0;i<=n;i++){ 
            const t=i/n; 
            const x=Math.round(b.x1+dx*t), y=Math.round(b.y1+dy*t); 
            const k=`${x},${y}`; 
            if(!used.has(k)){ 
              used.add(k); 
              this.nodes.set(k,{x,y,calcium:0,type:b.type,width:b.width}); 
              this.ip3.set(k,0);
            } 
          } 
        }); 
      }
      
      addCa(x,y,a){ 
        let best=null,bd=1e9; 
        this.nodes.forEach(n=>{ 
          const d=Math.hypot(n.x-x,n.y-y); 
          if(d<bd){bd=d; best=n} 
        }); 
        if(best && bd<30) best.calcium+=a; 
      }
      
      addIP3(x,y,a){ 
        let bestK=null,bd=1e9; 
        this.nodes.forEach((n,k)=>{ 
          const d=Math.hypot(n.x-x,n.y-y); 
          if(d<bd && d<30){bd=d; bestK=k} 
        }); 
        if(bestK){ 
          this.ip3.set(bestK,(this.ip3.get(bestK)||0)+a); 
        } 
      }
      
      sampleCa(x,y,r2=900){ 
        let tot=0,c=0; 
        this.nodes.forEach(n=>{ 
          const dx=n.x-x, dy=n.y-y; 
          const d2=dx*dx+dy*dy; 
          if(d2<r2){ tot+=n.calcium; c++; } 
        }); 
        return c?tot/c:0; 
      }
      
      update(dt){
        const diff=params.diffusionRate*0.01, dec=params.decayRate, er=params.erRelease, 
              ipT=params.ip3Threshold, spont=params.spontaneousRate, 
              cicrS=params.cicrSensitivity, cicrT=params.cicrThreshold, speed=params.simSpeed*0.1;
        const newCa=new Map(), newI=new Map(); 
        
        this.nodes.forEach((n,k)=>{ 
          newCa.set(k,n.calcium); 
          newI.set(k,this.ip3.get(k)||0); 
        });
        
        this.nodes.forEach((n,k)=>{
          const ca=n.calcium, ip=newI.get(k)||0;
          if(Math.random()<spont*speed*dt*60) newI.set(k, ip+0.3);
          if(ip>ipT){ 
            const rel=(ip-ipT)*er*speed; 
            newCa.set(k,ca+rel*dt); 
            newI.set(k, ip*(1-0.1*speed*dt)); 
          }
          if(ca>cicrT && cicrS>0){ 
            const c=(ca-cicrT)*cicrS*0.5*speed; 
            newCa.set(k,(newCa.get(k)||ca)+c*dt); 
            newI.set(k,(newI.get(k)||ip)+c*0.3*dt); 
            if(ca>cicrT*1.5){ 
              newI.set(k,(newI.get(k)||ip)+ (ca-cicrT*1.5)*0.4*speed*dt ); 
            } 
          }
          const decF = dec/(1+ca*0.5); 
          newCa.set(k,(newCa.get(k)||ca)*(1-decF*dt)); 
          newI.set(k,(newI.get(k)||ip)*(1-0.05*dt));
        });
        
        // Neighbor diffusion
        const nodesArr=[...this.nodes.values()];
        for(let i=0;i<nodesArr.length;i++){
          const a=nodesArr[i];
          for(let j=i+1;j<nodesArr.length;j++){
            const b=nodesArr[j]; 
            const dx=b.x-a.x, dy=b.y-a.y; 
            const d2=dx*dx+dy*dy; 
            if(d2<144){
              const deltaCa=(b.calcium-a.calcium)*diff*dt; 
              const ia=(this.ip3.get(`${a.x},${a.y}`)||0), ib=(this.ip3.get(`${b.x},${b.y}`)||0);
              newCa.set(`${a.x},${a.y}`,(newCa.get(`${a.x},${a.y}`)||a.calcium)+deltaCa);
              newCa.set(`${b.x},${b.y}`,(newCa.get(`${b.x},${b.y}`)||b.calcium)-deltaCa);
              const deltaI=(ib-ia)*diff*0.8*dt; 
              newI.set(`${a.x},${a.y}`,(newI.get(`${a.x},${a.y}`)||ia)+deltaI); 
              newI.set(`${b.x},${b.y}`,(newI.get(`${b.x},${b.y}`)||ib)-deltaI);
            }
          }
        }
        
        this.nodes.forEach((n,k)=>{ 
          n.calcium=clamp(newCa.get(k),0,5); 
          this.ip3.set(k,clamp(newI.get(k),0,3)); 
        });
      }
      
      draw(){
        ctx.save(); 
        ctx.translate(panX,panY); 
        ctx.scale(zoomLevel,zoomLevel);
        
        // Draw branches
        this.branches.forEach(b=>{ 
          ctx.strokeStyle = b.type==='endfoot' ? '#4fc3f7' : '#666'; 
          ctx.lineWidth = b.width/zoomLevel; 
          ctx.lineCap='round'; 
          ctx.beginPath(); 
          ctx.moveTo(b.x1,b.y1); 
          ctx.lineTo(b.x2,b.y2); 
          ctx.stroke(); 
          if(b.type==='endfoot'){ 
            ctx.fillStyle='#4fc3f7'; 
            ctx.beginPath(); 
            ctx.arc(b.x2,b.y2,5,0,Math.PI*2); 
            ctx.fill(); 
          }
        });
        
        // Draw soma
        ctx.fillStyle='#888'; 
        ctx.beginPath(); 
        ctx.arc(this.centerX,this.centerY,this.size/6,0,Math.PI*2); 
        ctx.fill();
        
        // Draw calcium
        this.nodes.forEach(n=>{ 
          if(n.calcium>0.01){ 
            const I=Math.min(1,n.calcium); 
            let r,g,b; 
            if(I<0.33){
              const t=I*3;
              r=Math.floor(255*t);
              g=Math.floor(255*t);
              b=0;
            } else if(I<0.66){
              const t=(I-0.33)*3;
              r=255;
              g=Math.floor(255*(1-t*0.5));
              b=0;
            } else {
              const t=(I-0.66)*3;
              r=255;
              g=Math.floor(128*(1-t));
              b=0;
            } 
            ctx.fillStyle=`rgb(${r},${g},${b})`; 
            const size=Math.max(1,2+I*4); 
            ctx.beginPath(); 
            ctx.arc(n.x,n.y,size,0,Math.PI*2); 
            ctx.fill(); 
            if(I>0.5){ 
              ctx.shadowColor=ctx.fillStyle; 
              ctx.shadowBlur=8; 
              ctx.beginPath(); 
              ctx.arc(n.x,n.y,size,0,Math.PI*2); 
              ctx.fill(); 
              ctx.shadowBlur=0; 
            } 
          }
        });
        
        ctx.restore();
      }
    }

    // -------------------- Game Objects --------------------
    class AxonPath{
      constructor(points){ 
        this.points=points; 
        this.segs=[]; 
        this.total=0; 
        for(let i=0;i<points.length-1;i++){ 
          const a=points[i], b=points[i+1]; 
          const L=Math.hypot(b.x-a.x,b.y-a.y); 
          this.segs.push({a,b,L}); 
          this.total+=L; 
        } 
      }
      
      posAt(u){
        let d = u*this.total; 
        for(const s of this.segs){ 
          if(d<=s.L){ 
            const t=d/s.L; 
            return {x:s.a.x+(s.b.x-s.a.x)*t, y:s.a.y+(s.b.y-s.a.y)*t}; 
          } 
          d-=s.L; 
        } 
        return this.segs.length?{x:this.segs.at(-1).b.x,y:this.segs.at(-1).b.y}:{x:0,y:0};
      }
    }

    class SpikePacket{ 
      constructor(axon,speed){ 
        this.axon=axon; 
        this.u=0; 
        this.speed=speed; 
        this.dead=false; 
      } 
      
      step(dt){ 
        this.u += (this.speed*dt)/this.axon.total; // Fixed: was axon.total
        if(this.u>=1){ 
          this.dead=true; 
        } 
      } 
      
      get pos(){ 
        return this.axon.posAt(this.u); 
      } 
    }

    class SynapseSite{ 
      constructor(p){ 
        this.x=p.x; 
        this.y=p.y; 
        this.G=0; 
      }
      
      draw(){ 
        // Simple white dots for synapses - glutamate shown via background
        ctx.fillStyle='#ffffff'; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,2,0,Math.PI*2); 
        ctx.fill(); 
        
        // Optional: small outline to make them more visible
        ctx.strokeStyle='#333333';
        ctx.lineWidth=1;
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,2,0,Math.PI*2); 
        ctx.stroke();
      }
    }

    class CaShot{ 
      constructor(src,dst){ 
        this.src=src; 
        this.dst=dst; 
        this.u=0; 
        this.dead=false; 
        this.dist=Math.hypot(dst.x-src.x,dst.y-src.y); 
      }
      
      step(dt){ 
        this.u += SHOT_SPEED*dt/Math.max(1,this.dist); 
        if(this.u>=1){ 
          this.u=1; 
          this.dead=true; 
          createCaExplosion(this.dst.x,this.dst.y); 
        } 
      }
      
      draw(){ 
        const p={ 
          x:this.src.x+(this.dst.x-this.src.x)*this.u, 
          y:this.src.y+(this.dst.y-this.src.y)*this.u 
        }; 
        ctx.save(); 
        ctx.strokeStyle='#26c6da'; 
        ctx.lineWidth=2; 
        ctx.beginPath(); 
        ctx.moveTo(this.src.x,this.src.y); 
        ctx.lineTo(p.x,p.y); 
        ctx.stroke(); 
        ctx.fillStyle='#26c6da'; 
        ctx.beginPath(); 
        ctx.arc(p.x,p.y,3,0,Math.PI*2); 
        ctx.fill(); 
        ctx.restore(); 
      }
    }

    function colorFromG(G){ 
      const t = clamp(G/6,0,1); 
      const r = 255; 
      const g = Math.floor(255*(1-t)); 
      const b = Math.floor(255*t); 
      return `rgb(${r},${g},${b})`; 
    }

    // -------------------- Game World Generation --------------------
    function generateAxonField(){
      axons=[]; 
      synapses=[]; 
      const w=canvas.width, h=canvas.height; 
      const margin=80;
      
      for(let i=0;i<AXON_COUNT;i++){
        const y1 = margin + (i+0.5)*( (h-2*margin)/AXON_COUNT );
        
        // Create smooth curved path using more control points
        const controlPoints = [];
        const numPoints = 20; // More points for smoother curves
        
        for(let j = 0; j <= numPoints; j++) {
          const t = j / numPoints;
          const x = margin + t * (w - 2*margin);
          
          // Create smooth sine wave variation
          const amplitude = 30 + Math.sin(i * 0.8) * 20; // Vary amplitude per axon
          const frequency = 0.015 + i * 0.002; // Slightly different frequencies
          const phase = i * 0.7; // Phase offset per axon
          
          const wobble = Math.sin(x * frequency + phase) * amplitude;
          
          controlPoints.push({x: x, y: y1 + wobble});
        }
        
        const ax = new AxonPath(controlPoints); 
        axons.push(ax);
        
        // Generate synapses along axon - skip first and last points
        const steps = Math.floor(ax.total/SYNAPSE_SPACING);
        for(let s=1; s<steps; s++){ 
          const p = ax.posAt(s/steps); 
          synapses.push(new SynapseSite(p)); 
        }
      }
    }

    // -------------------- Game Logic --------------------
    function spawnSpikes(dt){ 
      const rate = SPIKE_BASE_RATE * (1 + (wave-1)*0.35); 
      axons.forEach(ax=>{ 
        if(Math.random() < rate*dt){ 
          spikes.push(new SpikePacket(ax,SPIKE_SPEED*(0.9+Math.random()*0.25))); 
        } 
      }); 
    }

    function updateGlutamate(dt){
      // Spikes increase glutamate near synapses
      for(const sp of spikes){ 
        const p=sp.pos; 
        for(const s of synapses){ 
          const d2=(s.x-p.x)**2 + (s.y-p.y)**2; 
          if(d2 < SPIKE_EFFECT_R*SPIKE_EFFECT_R){ 
            const Ca = astrocyte.sampleCa(s.x,s.y); 
            const I = sigmoid((Ca-CA_THETA)/CA_SLOPE); 
            s.G += K_RELEASE*(1-I); 
          } 
        } 
      }
      
      // Decay glutamate with Ca-dependent uptake
      for(const s of synapses){ 
        const Ca = astrocyte.sampleCa(s.x,s.y); 
        const boost = 1 + UPTAKE_GAIN*sigmoid((Ca-CA_THETA)/CA_SLOPE); 
        const tau = TAU_UPTAKE/boost; 
        s.G -= (s.G/tau)*dt; 
        s.G = Math.max(0,s.G); 
      }
    }

    function excitabilitySum(){ 
      return synapses.reduce((a,s)=>a+s.G,0); 
    }

    function createCaExplosion(x,y){ 
      astrocyte.addIP3(x,y, SHOT_BLAST_IP3); 
      astrocyte.addCa(x,y, SHOT_BLAST_CA); 
      
      // Create visual explosion effect
      const explosionRadius = 25;
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const px = x + Math.cos(angle) * explosionRadius;
        const py = y + Math.sin(angle) * explosionRadius;
        astrocyte.addCa(px, py, SHOT_BLAST_CA * 0.3);
      }
      
      const localG = synapses.filter(s=> (s.x-x)**2 + (s.y-y)**2 < 900).reduce((a,s)=>a+s.G,0);
      const baseScore = 20;
      const glutamateBonus = Math.floor(localG * 1.5);
      const totalScore = baseScore + glutamateBonus;
      
      score += totalScore;
      
      // Show score popup effect would go here in a more advanced version
    }

    // -------------------- Leaderboard --------------------
    function loadBoard(){ 
      try{ 
        return JSON.parse(localStorage.getItem(BOARD_KEY)||'[]'); 
      }catch{ 
        return []; 
      } 
    }
    
    function saveBoard(arr){ 
      localStorage.setItem(BOARD_KEY, JSON.stringify(arr)); 
    }
    
    function addScore(name,score){ 
      const arr=loadBoard(); 
      arr.push({name:name||'Player',score,ts:Date.now()}); 
      arr.sort((a,b)=>b.score-a.score); 
      saveBoard(arr.slice(0,10)); 
      renderBoard(); 
    }
    
    function clearBoard(){ 
      localStorage.removeItem(BOARD_KEY); 
      renderBoard(); 
    }
    
    function renderBoard(){ 
      const el=document.getElementById('leaderboard'); 
      const arr=loadBoard(); 
      if(!arr.length){ 
        el.innerHTML='<div>No scores yet</div><div>‚Äî</div>'; 
        return; 
      } 
      el.innerHTML = arr.map((r,i)=>`<div>#${i+1} ${escapeHtml(r.name)}</div><div>${r.score}</div>`).join(''); 
    }
    
    const escapeHtml = s => (s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));

    // -------------------- Input Handling --------------------
    canvas.addEventListener('click', e=>{
      if(!running || ammo<=0) return; 
      
      const rect=canvas.getBoundingClientRect(); 
      const sx=e.clientX-rect.left, sy=e.clientY-rect.top; 
      const dst=screenToWorld(sx,sy);
      
      if(shotTimer>0) return; 
      
      const src = { x: canvas.width/2, y: canvas.height-40 }; // Fixed: complete the constructor call
      shots.push(new CaShot(src,dst)); 
      ammo--; 
      shotTimer=SHOT_COOLDOWN; 
      updateHUD();
    });

    // -------------------- HUD Updates --------------------
    function updateHUD(){ 
      document.getElementById('uiWave').textContent = wave; 
      document.getElementById('uiScore').textContent = score; 
      
      const ammoElement = document.getElementById('uiAmmo');
      ammoElement.textContent = ammo;
      
      // Color-code ammo based on remaining count
      const ammoStatus = document.querySelector('#uiAmmo').parentElement;
      if(ammo <= 2) {
        ammoStatus.style.color = '#ef5350'; // Red - critical
      } else if(ammo <= 4) {
        ammoStatus.style.color = '#ffd54f'; // Yellow - warning
      } else {
        ammoStatus.style.color = '#fff'; // White - normal
      }
    }

    // -------------------- Game Flow --------------------
    function startWave(){ 
      if(running) return;
      running=true; 
      ammo=SHOT_AMMO_PER_WAVE + Math.floor((wave-1)*0.5); 
      waveStartTime = lastStamp;
      updateHUD(); 
    }
    
    function nextWave(){ 
      wave++; 
      ammo = SHOT_AMMO_PER_WAVE + Math.floor((wave-1)*0.5); 
      aboveTime=0; 
      bestExcitability=Infinity; 
      waveStartTime = lastStamp;
      // Clear some state for new wave
      spikes = [];
      shots = [];
      synapses.forEach(s => s.G *= 0.3); // Reduce glutamate between waves
      updateHUD();
      
      // Show wave advancement message
      setTimeout(() => {
        alert(`Wave ${wave} begins! Spike rate increased.`);
      }, 100);
    }
    
    function resetAll(){ 
      running=false; 
      wave=1; 
      score=0; 
      ammo=0; 
      aboveTime=0; 
      bestExcitability=Infinity; 
      waveStartTime=0;
      spikes=[]; 
      shots=[]; 
      synapses=[]; 
      axons=[]; 
      generateWorld(); 
      updateHUD(); 
    }
    
    function gameOver(){ 
      running=false; 
      alert(`üí• Network runaway!\nFinal Wave: ${wave}\nFinal Score: ${score}`); 
    }

    function checkWaveComplete(currentTime) {
      if(!running) return;
      
      const timeInWave = currentTime - waveStartTime;
      const exc = excitabilitySum();
      
      // Lose condition 1: Run out of ammo with high excitability
      if(ammo <= 0 && exc > EXCIT_THRESH * 0.5) {
        setTimeout(() => {
          alert(`üí• Out of ammunition!\nExcitability too high to survive.\nFinal Wave: ${wave}\nFinal Score: ${score}`);
          running = false;
        }, 100);
        return;
      }
      
      // Lose condition 2: Out of ammo and can't complete wave time
      if(ammo <= 0 && timeInWave < waveDuration * 0.7) {
        setTimeout(() => {
          alert(`‚è∞ Out of ammunition too early!\nCouldn't survive the wave.\nFinal Wave: ${wave}\nFinal Score: ${score}`);
          running = false;
        }, 100);
        return;
      }
      
      // Win condition: survive wave duration with reasonable control OR run out of ammo late but with low excitability
      if((timeInWave >= waveDuration && exc < EXCIT_THRESH * 0.8) || 
         (ammo <= 0 && timeInWave >= waveDuration * 0.7 && exc < EXCIT_THRESH * 0.5)) {
        setTimeout(() => {
          const survivalBonus = ammo > 0 ? Math.floor(ammo * 50) : 0; // Bonus for leftover ammo
          const efficiencyBonus = Math.floor(1000/wave);
          alert(`Wave ${wave} Complete!\nScore: ${score}\nAmmo Bonus: ${survivalBonus}\nWave Bonus: ${efficiencyBonus}`);
          score += survivalBonus + efficiencyBonus;
          nextWave();
        }, 100);
      }
    }

    // -------------------- Main Animation Loop --------------------
    function animate(t=0){ 
      const ts=t*0.001; 
      const dt = Math.min(0.033, lastStamp? ts-lastStamp : 0.016); 
      lastStamp=ts; 
      
      if(!running){ 
        requestAnimationFrame(animate); 
        return; 
      }
      
      // Update timers
      shotTimer = Math.max(0, shotTimer-dt);
      
      // Update game systems
      spawnSpikes(dt);
      spikes.forEach(s=>s.step(dt)); 
      spikes = spikes.filter(s=>!s.dead);
      
      shots.forEach(sh=>sh.step(dt)); 
      shots = shots.filter(s=>!s.dead);
      
      updateGlutamate(dt);
      astrocyte.update(dt);

      // Scoring and wave progression
      const exc = excitabilitySum(); 
      bestExcitability = Math.min(bestExcitability, exc);
      score += Math.max(0, Math.floor(5 - exc*0.02)*dt*10);
      
      checkWaveComplete(ts);

      // Lose condition tracking
      const meter = document.getElementById('excMeter'); 
      const pct = clamp(exc/EXCIT_THRESH*100,0,100); 
      meter.style.width = Math.min(100,pct)+'%';
      
      if(exc>EXCIT_THRESH) { 
        aboveTime += dt; 
      } else { 
        aboveTime = Math.max(0, aboveTime-dt*0.5); 
      }
      
      if(aboveTime>=LOSE_HOLD){ 
        gameOver(); 
        requestAnimationFrame(animate);
        return;
      }

      // Render everything
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGlutamateBackground(); // Draw glutamate zones first (background)
      drawAxons();
      astrocyte.draw();
      drawSynapses();
      drawSpikes();
      drawShots();

      requestAnimationFrame(animate);
    }

    // -------------------- Drawing Functions --------------------
    function drawGlutamateBackground() {
      if(synapses.length === 0) return;
      
      ctx.save();
      
      // Create glutamate concentration zones with much higher visibility
      synapses.forEach(s => {
        if(s.G > 0.05) { // Show even lower concentrations
          const intensity = clamp(s.G / 6, 0, 1);
          const radius = 30 + intensity * 40; // Larger zones for better visibility
          
          // Create radial gradient for glutamate zone
          const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius);
          
          if(intensity < 0.2) {
            // Low concentration - more visible blue
            gradient.addColorStop(0, `rgba(100, 150, 255, ${0.3 + intensity * 0.4})`);
            gradient.addColorStop(0.7, `rgba(100, 150, 255, ${0.1 + intensity * 0.2})`);
            gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
          } else if(intensity < 0.5) {
            // Medium concentration - prominent purple
            gradient.addColorStop(0, `rgba(200, 100, 255, ${0.4 + intensity * 0.4})`);
            gradient.addColorStop(0.7, `rgba(200, 100, 255, ${0.2 + intensity * 0.3})`);
            gradient.addColorStop(1, 'rgba(200, 100, 255, 0)');
          } else {
            // High concentration - very prominent red
            gradient.addColorStop(0, `rgba(255, 80, 80, ${0.5 + intensity * 0.4})`);
            gradient.addColorStop(0.6, `rgba(255, 80, 80, ${0.3 + intensity * 0.3})`);
            gradient.addColorStop(1, 'rgba(255, 80, 80, 0)');
          }
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Add extra emphasis for very high concentrations
          if(intensity > 0.7) {
            const innerGradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius * 0.4);
            innerGradient.addColorStop(0, `rgba(255, 50, 50, ${intensity * 0.6})`);
            innerGradient.addColorStop(1, 'rgba(255, 50, 50, 0)');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(s.x, s.y, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      ctx.restore();
    }

    function drawAxons(){ 
      ctx.save(); 
      ctx.strokeStyle='#ff6b35'; 
      ctx.lineWidth=3; 
      ctx.lineCap='round';
      ctx.lineJoin='round';
      
      axons.forEach(ax=>{ 
        if(ax.points.length < 2) return;
        
        ctx.beginPath(); 
        ctx.moveTo(ax.points[0].x, ax.points[0].y);
        
        // Use quadratic curves for smooth appearance
        for(let i = 1; i < ax.points.length - 1; i++) {
          const current = ax.points[i];
          const next = ax.points[i + 1];
          const midX = (current.x + next.x) / 2;
          const midY = (current.y + next.y) / 2;
          
          ctx.quadraticCurveTo(current.x, current.y, midX, midY);
        }
        
        // Draw to the final point
        const lastPoint = ax.points[ax.points.length - 1];
        ctx.lineTo(lastPoint.x, lastPoint.y);
        
        ctx.stroke(); 
      }); 
      ctx.restore(); 
    }
    
    function drawSpikes(){ 
      ctx.save(); 
      spikes.forEach(s=>{ 
        const p=s.pos; 
        const speed = s.speed / SPIKE_SPEED; // Normalize speed for visual effect
        
        // Color based on speed - faster spikes are more dangerous
        if(speed > 1.1) {
          ctx.fillStyle='#ff4444'; // Fast spikes are red
        } else if(speed > 0.95) {
          ctx.fillStyle='#ffaa44'; // Medium spikes are orange  
        } else {
          ctx.fillStyle='#ffffff'; // Slow spikes are white
        }
        
        const size = 2 + speed * 2; // Size indicates speed
        ctx.beginPath(); 
        ctx.arc(p.x,p.y,size,0,Math.PI*2); 
        ctx.fill(); 
        
        // Add trailing effect for fast spikes
        if(speed > 1.05) {
          ctx.globalAlpha = 0.3;
          const trail = s.axon.posAt(Math.max(0, s.u - 0.02));
          ctx.beginPath(); 
          ctx.arc(trail.x,trail.y,size*0.7,0,Math.PI*2); 
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }); 
      ctx.restore(); 
    }
    
    function drawSynapses(){ 
      synapses.forEach(s=>s.draw()); 
    }
    
    function drawShots(){ 
      shots.forEach(s=>s.draw()); 
    }

    // -------------------- World Initialization --------------------
    function generateWorld(){ 
      astrocyte = new AstrocyteStructure(canvas.width/2, canvas.height/2, 120); 
      generateAxonField(); 
      renderBoard(); 
    }

    // -------------------- UI Event Handlers --------------------
    document.getElementById('startBtn').addEventListener('click', ()=>{ 
      if(!running){ 
        startWave(); 
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', resetAll);
    
    document.getElementById('saveScoreBtn').addEventListener('click', ()=>{ 
      const name=(document.getElementById('playerName').value||'Player').trim().slice(0,16); 
      addScore(name,Math.floor(score)); 
    });
    
    document.getElementById('clearBoardBtn').addEventListener('click', clearBoard);

    // -------------------- Canvas Management --------------------
    function resizeCanvas(){ 
      const area=document.querySelector('.simulation-area'); 
      const newWidth = area.clientWidth;
      const newHeight = area.clientHeight;
      
      // Only regenerate if size actually changed significantly
      if(Math.abs(canvas.width - newWidth) > 10 || Math.abs(canvas.height - newHeight) > 10) {
        canvas.width = newWidth; 
        canvas.height = newHeight; 
        generateWorld(); 
      }
    }

    // -------------------- Initialization --------------------
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', ()=>{ 
      resizeCanvas(); 
      updateHUD(); 
      requestAnimationFrame(animate); 
    });
  </script>
</body>
</html>