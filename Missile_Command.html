<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-touch-fullscreen" content="yes" />
  <title>Calcium Cascade ‚Äì Missile Command Mode</title>
  <style>
    :root {
      --bg1:#1e3c72; --bg2:#2a5298; --accent:#4fc3f7; --ok:#81c784; --warn:#ffd54f; --bad:#ef5350;
    }
    *{box-sizing:border-box}
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:#fff;overflow:hidden;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent}
    .container{display:flex;height:100vh;height:100dvh}
    .controls{width:320px;background:rgba(0,0,0,.8);padding:18px;overflow-y:auto;backdrop-filter:blur(10px)}
    .simulation-area{flex:1;position:relative;background:#000}
    h1{margin:0 0 12px 0;font-size:18px;color:var(--accent)}
    .control-group{margin-bottom:16px;padding:12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);border-radius:10px}
    .control-group h3{margin:0 0 8px 0;font-size:14px;color:var(--ok)}
    label{display:block;margin:6px 0 4px 0;font-size:12px;color:#ddd}
    input[type="text"],select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.1);color:#fff}
    button{padding:10px 14px;margin:6px 6px 0 0;background:linear-gradient(45deg,#4fc3f7,#29b6f6);border:none;border-radius:8px;color:white;cursor:pointer;font-size:14px;font-weight:600;min-height:40px}
    button.alt{background:linear-gradient(45deg,#ff9800,#f57c00)}
    button.danger{background:linear-gradient(45deg,#ef5350,#e53935)}
    button.secondary{background:linear-gradient(45deg,#607d8b,#455a64)}
    .row{display:flex;gap:8px}
    .row>*{flex:1}
    .status{position:absolute;top:12px;left:12px;background:rgba(0,0,0,.6);padding:10px 12px;border-radius:10px;font-size:12px}
    .status .meter{width:220px;height:10px;background:#222;border-radius:6px;overflow:hidden;margin-top:6px}
    .status .meter>div{height:100%;background:linear-gradient(90deg,#66bb6a,#ffee58,#ef5350);width:0%}
    canvas{border:2px solid rgba(255,255,255,.25);cursor:crosshair}
    .legend{position:absolute;bottom:12px;left:12px;background:rgba(0,0,0,.6);padding:10px 12px;border-radius:10px;font-size:11px}
    .board{display:grid;grid-template-columns:1fr auto;gap:6px;margin-top:8px}
    .board div{padding:6px 8px;background:rgba(255,255,255,.06);border-radius:6px}
    .small{font-size:11px;opacity:.9}
    @media (max-width:1024px){.container{flex-direction:column}.controls{width:100%;height:32vh}.simulation-area{height:68vh}}
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <h1>üß† Calcium Cascade ‚Äì Missile Command</h1>

      <div class="control-group">
        <h3>Player</h3>
        <label for="playerName">Name</label>
        <input id="playerName" type="text" placeholder="e.g., Ada" maxlength="16" />
        <label style="display:flex;align-items:center;gap:8px;margin-top:10px;cursor:pointer">
          <input type="checkbox" id="hemichannelToggle" style="width:auto;margin:0" />
          <span>Hemichannel Mode (ATP propagation)</span>
        </label>
        <div class="row">
          <button id="startBtn">Start Game ‚ñ∂</button>
          <button id="resetBtn" class="alt">Reset üîÑ</button>
        </div>
      </div>

      <div class="control-group">
        <h3>Leaderboard (Local)</h3>
        <div id="leaderboard" class="board"></div>
        <div class="row">
          <button id="saveScoreBtn" class="secondary">Save Score üíæ</button>
          <button id="clearBoardBtn" class="danger">Clear Board üßπ</button>
        </div>
        <div class="small">Scores are stored in your browser (localStorage).</div>
      </div>

      <div class="control-group">
        <h3>Tips</h3>
        <div class="small">‚Ä¢ Click to fire a Ca¬≤‚Å∫ shot that travels and detonates.<br/>‚Ä¢ Keep the excitability bar low by suppressing glutamate near synapses.<br/>‚Ä¢ Chain CICR for bigger suppression!<br/>‚Ä¢ Ammo is limited per wave.</div>
      </div>
    </div>

    <div class="simulation-area">
      <canvas id="canvas" width="1280" height="800"></canvas>
      <div class="status">
        <div style="font-size:28px;font-weight:bold;margin-bottom:8px;color:var(--accent);text-align:center"><span id="uiTime">1:00</span></div>
        <div><strong>Score:</strong> <span id="uiScore">0</span> &nbsp;‚Ä¢&nbsp; <strong>Shots:</strong> <span id="uiAmmo">0</span></div>
        <div style="margin-top:6px"><strong>Excitability</strong></div>
        <div class="meter"><div id="excMeter"></div></div>
        <div class="small" id="uiDebug"></div>
      </div>
      <div class="legend small">
        <strong>How it works:</strong> Spikes trigger glutamate at synapses (blue‚Üíred zones). Fire Ca¬≤‚Å∫ shots to flood astrocyte with calcium, which BLOCKS glutamate release and speeds uptake. Green shields = protected synapses!
      </div>
    </div>
  </div>

  <script>
    // ----------------- Simulation constants -----------------
    const params = {
      diffusionRate: 1.1, decayRate: 0.035, erRelease: 0.85, ip3Threshold: 0.55,
      spontaneousRate: 0.001, hemichannelStrength: 0.4, cicrSensitivity: 0.9,
      cicrThreshold: 0.42, simSpeed: 1.0, mgluR: 1.0, atpSens: 1.0
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // World view
    let zoomLevel = 1.0, panX = 0, panY = 0;

    // Game state
    let running = false;
    let score = 0;
    let gameStartTime = 0;
    let gameDuration = 60; // 60 seconds total
    let shotsThisGame = 0; // Track shots for scoring penalty
    let hemichannelMode = false; // Toggle for hemichannel ATP signaling

    // Missile Command mode systems
    const AXON_COUNT = 5;
    const SYNAPSE_SPACING = 110;
    const SPIKE_BASE_RATE = 0.45;
    const SPIKE_SPEED = 320;
    const SHOT_SPEED = 700;
    const SHOT_BLAST_IP3 = 1.2;
    const SHOT_BLAST_CA = 0.8;
    const SHOT_COOLDOWN = 0.45;
    const SHOT_AMMO_PER_WAVE = 15; // Increased ammo for more forgiving gameplay
    const SPIKE_EFFECT_R = 26;
    const K_RELEASE = 0.085;
    const TAU_UPTAKE = 1.8;
    const UPTAKE_GAIN = 2.7;
    const CA_THETA = 0.45, CA_SLOPE = 0.16;
    const EXCIT_THRESH = 80;
    const LOSE_HOLD = 1.5;

    // Structures
    let astrocyte = null;
    let axons = [];
    let synapses = [];
    let spikes = [];
    let shots = [];
    let lastStamp = 0;
    let aboveTime = 0;
    let shotTimer = 0;

    // Leaderboard
    const BOARD_KEY = 'cc_leaderboard_v2';

    // -------------------- Geometry helpers --------------------
    function worldToScreen(x,y){return {x: x*zoomLevel+panX, y: y*zoomLevel+panY}}
    function screenToWorld(x,y){return {x: (x-panX)/zoomLevel, y: (y-panY)/zoomLevel}}
    function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
    const sigmoid = z => 1/(1+Math.exp(-z));

    // -------------------- Astrocyte Structure --------------------
    class AstrocyteStructure{
      constructor(cx,cy,size){ 
        this.centerX=cx; this.centerY=cy; this.size=size; 
        this.branches=[]; this.nodes=new Map(); this.ip3=new Map(); 
        this.generate(); 
      }
      
      generate(){
        this.branches=[]; this.nodes.clear(); this.ip3.clear();
        const primaryLen=75, branchLevels=4, processWidth=4, branchAngle=40*Math.PI/180; // Shorter, wider angles
        this.branches.push({x1:this.centerX,y1:this.centerY,x2:this.centerX,y2:this.centerY,width:this.size/4,type:'soma'});
        const primary=10; // Even more primary branches for coverage
        for(let i=0;i<primary;i++){ 
          const a=i/primary*2*Math.PI; 
          this._branch(this.centerX,this.centerY,a,primaryLen,branchLevels,processWidth,0,branchAngle); 
        }
        this._makeNodes();
      }
      
      _branch(x,y,ang,len,levels,width,level,branchAngle){ 
        if(levels<=0) return; 
        const ex=x+Math.cos(ang)*len, ey=y+Math.sin(ang)*len; 
        this.branches.push({x1:x,y1:y,x2:ex,y2:ey,width,type:levels===1?'endfoot':'process'});
        if(levels>1){ 
          const num = Math.random()>0.3?2:3; 
          for(let i=0;i<num;i++){ 
            const sa=ang+(i-(num-1)/2)*branchAngle+(Math.random()-0.5)*0.25; 
            this._branch(ex,ey,sa,len*0.72*(0.85+Math.random()*0.3),levels-1,Math.max(1,width*0.82),level+1,branchAngle); 
          } 
        }
      }
      
      _makeNodes(){ 
        const spacing=5, used=new Set(); // Denser node spacing for better coverage
        this.branches.forEach(b=>{ 
          const dx=b.x2-b.x1, dy=b.y2-b.y1; 
          const L=Math.hypot(dx,dy); 
          const n=Math.max(1,Math.floor(L/spacing)); 
          for(let i=0;i<=n;i++){ 
            const t=i/n; 
            const x=Math.round(b.x1+dx*t), y=Math.round(b.y1+dy*t); 
            const k=`${x},${y}`; 
            if(!used.has(k)){ 
              used.add(k); 
              this.nodes.set(k,{x,y,calcium:0,type:b.type,width:b.width}); 
              this.ip3.set(k,0);
            } 
          } 
        }); 
      }
      
      addCa(x,y,a){ 
        let best=null,bd=1e9; 
        this.nodes.forEach(n=>{ 
          const d=Math.hypot(n.x-x,n.y-y); 
          if(d<bd){bd=d; best=n} 
        }); 
        if(best && bd<30) best.calcium+=a; 
      }
      
      addIP3(x,y,a){ 
        let bestK=null,bd=1e9; 
        this.nodes.forEach((n,k)=>{ 
          const d=Math.hypot(n.x-x,n.y-y); 
          if(d<bd && d<30){bd=d; bestK=k} 
        }); 
        if(bestK){ 
          this.ip3.set(bestK,(this.ip3.get(bestK)||0)+a); 
        } 
      }
      
      sampleCa(x,y,r2=900){ 
        let tot=0,c=0; 
        this.nodes.forEach(n=>{ 
          const dx=n.x-x, dy=n.y-y; 
          const d2=dx*dx+dy*dy; 
          if(d2<r2){ tot+=n.calcium; c++; } 
        }); 
        return c?tot/c:0; 
      }
      
      update(dt){
        const diff=params.diffusionRate*0.01, dec=params.decayRate * 2.5, er=params.erRelease, 
              ipT=params.ip3Threshold, spont=params.spontaneousRate, 
              cicrS=params.cicrSensitivity, cicrT=params.cicrThreshold, speed=params.simSpeed*0.1;
        const newCa=new Map(), newI=new Map(); 
        
        this.nodes.forEach((n,k)=>{ 
          newCa.set(k,n.calcium); 
          newI.set(k,this.ip3.get(k)||0); 
        });
        
        this.nodes.forEach((n,k)=>{
          const ca=n.calcium, ip=newI.get(k)||0;
          if(Math.random()<spont*speed*dt*60) newI.set(k, ip+0.3);
          
          // IP3-triggered ER release
          if(ip>ipT){ 
            const rel=(ip-ipT)*er*speed*0.8; // Reduced release strength
            newCa.set(k,ca+rel*dt); 
            newI.set(k, ip*(1-0.15*speed*dt)); // Faster IP3 consumption
          }
          
          // CICR - but with saturation to prevent runaway
          if(ca>cicrT && cicrS>0 && ca < 2.0){ // Only trigger CICR if Ca below saturation
            const c=(ca-cicrT)*cicrS*0.3*speed; // Reduced CICR strength
            newCa.set(k,(newCa.get(k)||ca)+c*dt); 
            newI.set(k,(newI.get(k)||ip)+c*0.2*dt); // Reduced IP3 production
          }
          
          // Strong exponential decay - higher concentrations decay faster
          const decayRate = dec * (1 + ca * 0.3); // Now high Ca decays FASTER
          newCa.set(k,(newCa.get(k)||ca)*(1-decayRate*dt)); 
          newI.set(k,(newI.get(k)||ip)*(1-0.12*dt)); // Faster IP3 decay
        });
        
        // Neighbor diffusion
        const nodesArr=[...this.nodes.values()];
        for(let i=0;i<nodesArr.length;i++){
          const a=nodesArr[i];
          for(let j=i+1;j<nodesArr.length;j++){
            const b=nodesArr[j]; 
            const dx=b.x-a.x, dy=b.y-a.y; 
            const d2=dx*dx+dy*dy; 
            if(d2<144){
              const deltaCa=(b.calcium-a.calcium)*diff*dt; 
              const ia=(this.ip3.get(`${a.x},${a.y}`)||0), ib=(this.ip3.get(`${b.x},${b.y}`)||0);
              newCa.set(`${a.x},${a.y}`,(newCa.get(`${a.x},${a.y}`)||a.calcium)+deltaCa);
              newCa.set(`${b.x},${b.y}`,(newCa.get(`${b.x},${b.y}`)||b.calcium)-deltaCa);
              const deltaI=(ib-ia)*diff*0.8*dt; 
              newI.set(`${a.x},${a.y}`,(newI.get(`${a.x},${a.y}`)||ia)+deltaI); 
              newI.set(`${b.x},${b.y}`,(newI.get(`${b.x},${b.y}`)||ib)-deltaI);
            }
          }
        }
        
        this.nodes.forEach((n,k)=>{ 
          n.calcium=clamp(newCa.get(k),0,5); 
          this.ip3.set(k,clamp(newI.get(k),0,3)); 
        });
      }
      
      draw(){
        ctx.save(); 
        ctx.translate(panX,panY); 
        ctx.scale(zoomLevel,zoomLevel);
        
        // Draw branches
        this.branches.forEach(b=>{ 
          ctx.strokeStyle = b.type==='endfoot' ? '#4fc3f7' : '#666'; 
          ctx.lineWidth = b.width/zoomLevel; 
          ctx.lineCap='round'; 
          ctx.beginPath(); 
          ctx.moveTo(b.x1,b.y1); 
          ctx.lineTo(b.x2,b.y2); 
          ctx.stroke(); 
          if(b.type==='endfoot'){ 
            ctx.fillStyle='#4fc3f7'; 
            ctx.beginPath(); 
            ctx.arc(b.x2,b.y2,5,0,Math.PI*2); 
            ctx.fill(); 
          }
        });
        
        // Draw soma
        ctx.fillStyle='#888'; 
        ctx.beginPath(); 
        ctx.arc(this.centerX,this.centerY,this.size/6,0,Math.PI*2); 
        ctx.fill();
        
        // Draw calcium
        this.nodes.forEach(n=>{ 
          if(n.calcium>0.01){ 
            const I=Math.min(1,n.calcium); 
            let r,g,b; 
            if(I<0.33){
              const t=I*3;
              r=Math.floor(255*t);
              g=Math.floor(255*t);
              b=0;
            } else if(I<0.66){
              const t=(I-0.33)*3;
              r=255;
              g=Math.floor(255*(1-t*0.5));
              b=0;
            } else {
              const t=(I-0.66)*3;
              r=255;
              g=Math.floor(128*(1-t));
              b=0;
            } 
            ctx.fillStyle=`rgb(${r},${g},${b})`; 
            const size=Math.max(1,2+I*4); 
            ctx.beginPath(); 
            ctx.arc(n.x,n.y,size,0,Math.PI*2); 
            ctx.fill(); 
            if(I>0.5){ 
              ctx.shadowColor=ctx.fillStyle; 
              ctx.shadowBlur=8; 
              ctx.beginPath(); 
              ctx.arc(n.x,n.y,size,0,Math.PI*2); 
              ctx.fill(); 
              ctx.shadowBlur=0; 
            } 
          }
        });
        
        ctx.restore();
      }
    }

    // -------------------- Game Objects --------------------
    class AxonPath{
      constructor(points){ 
        this.points=points; 
        this.segs=[]; 
        this.total=0; 
        for(let i=0;i<points.length-1;i++){ 
          const a=points[i], b=points[i+1]; 
          const L=Math.hypot(b.x-a.x,b.y-a.y); 
          this.segs.push({a,b,L}); 
          this.total+=L; 
        } 
      }
      
      posAt(u){
        let d = u*this.total; 
        for(const s of this.segs){ 
          if(d<=s.L){ 
            const t=d/s.L; 
            return {x:s.a.x+(s.b.x-s.a.x)*t, y:s.a.y+(s.b.y-s.a.y)*t}; 
          } 
          d-=s.L; 
        } 
        return this.segs.length?{x:this.segs.at(-1).b.x,y:this.segs.at(-1).b.y}:{x:0,y:0};
      }
    }

    class SpikePacket{ 
      constructor(axon,speed){ 
        this.axon=axon; 
        this.u=0; 
        this.speed=speed; 
        this.dead=false;
        this.triggeredSynapses=new Set(); // Track which synapses already released glutamate
      } 
      
      step(dt){ 
        this.u += (this.speed*dt)/this.axon.total;
        if(this.u>=1){ 
          this.dead=true; 
        } 
      } 
      
      get pos(){ 
        return this.axon.posAt(this.u); 
      } 
    }

    class SynapseSite{ 
      constructor(p){ 
        this.x=p.x; 
        this.y=p.y; 
        this.G=0;
        this.protectionLevel=0; // Visual indicator of calcium protection (0-1)
      }
      
      draw(){ 
        // Show protection shield when calcium is present - DRAW FIRST (behind synapse)
        if(this.protectionLevel > 0.05) {
          const shieldRadius = 10 + this.protectionLevel * 12;
          const shieldAlpha = 0.5 + this.protectionLevel * 0.5;
          
          // Outer glow - bright green
          ctx.strokeStyle=`rgba(0, 255, 100, ${shieldAlpha * 0.6})`;
          ctx.lineWidth=3;
          ctx.shadowColor=`rgba(0, 255, 100, ${shieldAlpha})`;
          ctx.shadowBlur=10;
          ctx.beginPath(); 
          ctx.arc(this.x,this.y,shieldRadius,0,Math.PI*2); 
          ctx.stroke();
          ctx.shadowBlur=0;
          
          // Inner ring for strong protection
          if(this.protectionLevel > 0.3) {
            ctx.strokeStyle=`rgba(100, 255, 150, ${shieldAlpha})`;
            ctx.lineWidth=2;
            ctx.beginPath(); 
            ctx.arc(this.x,this.y,shieldRadius - 4,0,Math.PI*2); 
            ctx.stroke();
          }
          
          // Filled circle for very strong protection
          if(this.protectionLevel > 0.6) {
            const fillGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, shieldRadius - 6);
            fillGradient.addColorStop(0, `rgba(100, 255, 150, ${shieldAlpha * 0.3})`);
            fillGradient.addColorStop(1, 'rgba(100, 255, 150, 0)');
            ctx.fillStyle = fillGradient;
            ctx.beginPath(); 
            ctx.arc(this.x,this.y,shieldRadius - 6,0,Math.PI*2); 
            ctx.fill();
          }
        }
        
        // Base synapse - white dot ON TOP
        ctx.fillStyle='#ffffff'; 
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,3,0,Math.PI*2); 
        ctx.fill(); 
        
        // Small outline for visibility
        ctx.strokeStyle='#333333';
        ctx.lineWidth=1;
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,3,0,Math.PI*2); 
        ctx.stroke();
      }
    }

    class CaShot{ 
      constructor(src,dst){ 
        this.src=src; 
        this.dst=dst; 
        this.u=0; 
        this.dead=false; 
        this.dist=Math.hypot(dst.x-src.x,dst.y-src.y); 
      }
      
      step(dt){ 
        this.u += SHOT_SPEED*dt/Math.max(1,this.dist); 
        if(this.u>=1){ 
          this.u=1; 
          this.dead=true; 
          createCaExplosion(this.dst.x,this.dst.y); 
        } 
      }
      
      draw(){ 
        const p={ 
          x:this.src.x+(this.dst.x-this.src.x)*this.u, 
          y:this.src.y+(this.dst.y-this.src.y)*this.u 
        }; 
        ctx.save(); 
        ctx.strokeStyle='#26c6da'; 
        ctx.lineWidth=2; 
        ctx.beginPath(); 
        ctx.moveTo(this.src.x,this.src.y); 
        ctx.lineTo(p.x,p.y); 
        ctx.stroke(); 
        ctx.fillStyle='#26c6da'; 
        ctx.beginPath(); 
        ctx.arc(p.x,p.y,3,0,Math.PI*2); 
        ctx.fill(); 
        ctx.restore(); 
      }
    }

    function colorFromG(G){ 
      const t = clamp(G/6,0,1); 
      const r = 255; 
      const g = Math.floor(255*(1-t)); 
      const b = Math.floor(255*t); 
      return `rgb(${r},${g},${b})`; 
    }

    // -------------------- Game World Generation --------------------
    function generateAxonField(){
      axons=[]; 
      synapses=[]; 
      const w=canvas.width, h=canvas.height; 
      const margin=80;
      
      // Generate 5 axons but centered (skip outer positions)
      const totalPositions = 7; // Calculate spacing for 7 positions but only use middle 5
      
      for(let i=1; i<=5; i++){ // Use positions 1-5 (skip 0 and 6)
        // Vertical layout - distribute across width
        const x1 = margin + (i+0.5)*( (w-2*margin)/totalPositions );
        
        // Create smooth curved path using more control points (top to bottom)
        const controlPoints = [];
        const numPoints = 20; // More points for smoother curves
        
        for(let j = 0; j <= numPoints; j++) {
          const t = j / numPoints;
          const y = margin + t * (h - 2*margin); // Top to bottom
          
          // Create smooth sine wave variation in x direction
          const amplitude = 25 + Math.sin(i * 0.6) * 15; // Vary amplitude per axon
          const frequency = 0.012 + i * 0.0015; // Slightly different frequencies
          const phase = i * 0.5; // Phase offset per axon
          
          const wobble = Math.sin(y * frequency + phase) * amplitude;
          
          controlPoints.push({x: x1 + wobble, y: y});
        }
        
        const ax = new AxonPath(controlPoints); 
        axons.push(ax);
        
        // Generate synapses along axon - skip first and last points
        const steps = Math.floor(ax.total/SYNAPSE_SPACING);
        for(let s=1; s<steps; s++){ 
          const p = ax.posAt(s/steps); 
          synapses.push(new SynapseSite(p)); 
        }
      }
    }

    // -------------------- Game Logic --------------------
    function spawnSpikes(dt){ 
      const rate = SPIKE_BASE_RATE; // Constant rate, no wave scaling
      axons.forEach(ax=>{ 
        if(Math.random() < rate*dt){ 
          spikes.push(new SpikePacket(ax,SPIKE_SPEED*(0.9+Math.random()*0.25))); 
        } 
      }); 
    }

    function updateGlutamate(dt){
      // First, update protection levels based on local calcium
      for(const s of synapses) {
        const Ca = astrocyte.sampleCa(s.x, s.y);
        // Protection level tracks calcium concentration (normalized 0-1)
        // More sensitive threshold so shields appear more readily
        s.protectionLevel = clamp(Ca / 1.2, 0, 1); // Ca of 1.2+ = full protection
      }
      
      // Spikes trigger glutamate release ONCE per synapse encounter
      for(const sp of spikes){ 
        const p=sp.pos; 
        for(let i=0; i<synapses.length; i++){ 
          const s = synapses[i];
          const d2=(s.x-p.x)**2 + (s.y-p.y)**2; 
          
          // Check if spike is within range AND hasn't triggered this synapse yet
          if(d2 < SPIKE_EFFECT_R*SPIKE_EFFECT_R && !sp.triggeredSynapses.has(i)){ 
            const Ca = astrocyte.sampleCa(s.x,s.y);
            // Sigmoid function: converts calcium to inhibition (0-1 range)
            const inhibition = sigmoid((Ca-CA_THETA)/CA_SLOPE);
            const release = K_RELEASE * (1 - inhibition);
            s.G += release;
            
            // Mark this synapse as triggered by this spike
            sp.triggeredSynapses.add(i);
          } 
        } 
      }
      
      // Decay glutamate with Ca-dependent uptake
      for(const s of synapses){ 
        const Ca = astrocyte.sampleCa(s.x,s.y);
        // Higher calcium = faster uptake (astrocyte clearing glutamate)
        const boost = 1 + UPTAKE_GAIN*sigmoid((Ca-CA_THETA)/CA_SLOPE); 
        const tau = TAU_UPTAKE/boost; 
        s.G -= (s.G/tau)*dt; 
        s.G = Math.max(0,s.G); 
      }
    }

    function excitabilitySum(){ 
      return synapses.reduce((a,s)=>a+s.G,0); 
    }

    function createCaExplosion(x,y){ 
      astrocyte.addIP3(x,y, SHOT_BLAST_IP3); 
      astrocyte.addCa(x,y, SHOT_BLAST_CA); 
      
      // Create visual explosion effect
      const explosionRadius = 25;
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const px = x + Math.cos(angle) * explosionRadius;
        const py = y + Math.sin(angle) * explosionRadius;
        astrocyte.addCa(px, py, SHOT_BLAST_CA * 0.3);
      }
      
      // Hemichannel mode: ATP propagation to neighboring synapses
      if(hemichannelMode) {
        const atpRadius = 80; // Propagation radius
        const atpStrength = 0.4; // IP3 boost to nearby areas
        
        synapses.forEach(s => {
          const dist = Math.hypot(s.x - x, s.y - y);
          if(dist < atpRadius && dist > 10) {
            // Distance-based falloff
            const falloff = 1 - (dist / atpRadius);
            astrocyte.addIP3(s.x, s.y, atpStrength * falloff);
            astrocyte.addCa(s.x, s.y, SHOT_BLAST_CA * 0.15 * falloff);
          }
        });
      }
      
      const localG = synapses.filter(s=> (s.x-x)**2 + (s.y-y)**2 < 900).reduce((a,s)=>a+s.G,0);
      const baseScore = 20;
      const glutamateBonus = Math.floor(localG * 1.5);
      const totalScore = baseScore + glutamateBonus;
      
      score += totalScore;
    }

    // -------------------- Leaderboard --------------------
    function loadBoard(){ 
      try{ 
        return JSON.parse(localStorage.getItem(BOARD_KEY)||'[]'); 
      }catch{ 
        return []; 
      } 
    }
    
    function saveBoard(arr){ 
      localStorage.setItem(BOARD_KEY, JSON.stringify(arr)); 
    }
    
    function addScore(name,score){ 
      const arr=loadBoard(); 
      arr.push({name:name||'Player',score,ts:Date.now()}); 
      arr.sort((a,b)=>b.score-a.score); 
      saveBoard(arr.slice(0,10)); 
      renderBoard(); 
    }
    
    function clearBoard(){ 
      localStorage.removeItem(BOARD_KEY); 
      renderBoard(); 
    }
    
    function renderBoard(){ 
      const el=document.getElementById('leaderboard'); 
      const arr=loadBoard(); 
      if(!arr.length){ 
        el.innerHTML='<div>No scores yet</div><div>‚Äî</div>'; 
        return; 
      } 
      el.innerHTML = arr.map((r,i)=>`<div>#${i+1} ${escapeHtml(r.name)}</div><div>${r.score}</div>`).join(''); 
    }
    
    const escapeHtml = s => (s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));

    // -------------------- Input Handling --------------------
    canvas.addEventListener('click', e=>{
      if(!running) return;
      
      const rect=canvas.getBoundingClientRect(); 
      const sx=e.clientX-rect.left, sy=e.clientY-rect.top; 
      const dst=screenToWorld(sx,sy);
      
      if(shotTimer>0) return; 
      
      const src = { x: canvas.width/2, y: canvas.height-40 };
      shots.push(new CaShot(src,dst)); 
      
      shotsThisGame++; // Track total shots
      
      shotTimer=SHOT_COOLDOWN; 
      updateHUD();
    });

    // -------------------- HUD Updates --------------------
    function updateHUD(){ 
      document.getElementById('uiScore').textContent = score; 
      
      // Update timer with prominent countdown
      const timeRemaining = Math.max(0, gameDuration - (lastStamp - gameStartTime));
      const minutes = Math.floor(timeRemaining / 60);
      const seconds = Math.floor(timeRemaining % 60);
      const timerElement = document.getElementById('uiTime');
      timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Color code timer based on urgency
      if(timeRemaining <= 10) {
        timerElement.style.color = '#ef5350'; // Red - urgent
      } else if(timeRemaining <= 30) {
        timerElement.style.color = '#ffd54f'; // Yellow - warning
      } else {
        timerElement.style.color = '#4fc3f7'; // Cyan - normal
      }
      
      const ammoElement = document.getElementById('uiAmmo');
      ammoElement.textContent = shotsThisGame;
      
      // Color-code based on efficiency
      const ammoStatus = document.querySelector('#uiAmmo').parentElement;
      const optimalShots = 20; // Target for 60 seconds
      
      if(shotsThisGame <= optimalShots) {
        ammoStatus.style.color = '#81c784'; // Green - efficient
      } else if(shotsThisGame <= optimalShots * 1.5) {
        ammoStatus.style.color = '#ffd54f'; // Yellow - acceptable
      } else {
        ammoStatus.style.color = '#ef5350'; // Red - wasteful
      }
    }

    // -------------------- Game Flow --------------------
    function startGame(){ 
      if(running) return;
      running=true; 
      shotsThisGame = 0;
      score = 0;
      gameStartTime = lastStamp;
      // Clear state
      spikes = [];
      shots = [];
      synapses.forEach(s => s.G = 0);
      updateHUD(); 
    }
    
    function resetAll(){ 
      running=false; 
      score=0; 
      shotsThisGame=0;
      aboveTime=0; 
      gameStartTime=0;
      lastStamp=0; // Reset timestamp
      spikes=[]; 
      shots=[]; 
      synapses=[]; 
      axons=[]; 
      generateWorld(); 
      
      // Manually reset timer display
      document.getElementById('uiTime').textContent = '1:00';
      document.getElementById('uiTime').style.color = '#4fc3f7';
      document.getElementById('uiScore').textContent = '0';
      document.getElementById('uiAmmo').textContent = '0';
      document.querySelector('#uiAmmo').parentElement.style.color = '#81c784';
      document.getElementById('excMeter').style.width = '0%';
    }
    
    function gameOver(){ 
      running=false; 
      alert(`üí• Network runaway!\nExcitability overload!\nFinal Score: ${score}`); 
    }

    function checkGameComplete(currentTime) {
      if(!running) return;
      
      const timeElapsed = currentTime - gameStartTime;
      const exc = excitabilitySum();
      
      // Game complete: 60 seconds elapsed
      if(timeElapsed >= gameDuration) {
        running = false; // Immediately stop to prevent multiple triggers
        
        setTimeout(() => {
          const optimalShots = 20;
          const excessShots = Math.max(0, shotsThisGame - optimalShots);
          
          // Penalty: -10 points per excess shot
          const efficiencyPenalty = excessShots * 10;
          const finalScore = score - efficiencyPenalty;
          score = Math.max(0, finalScore); // Can't go negative
          
          let efficiencyMsg = '';
          if(excessShots === 0) {
            efficiencyMsg = `\n‚úì Perfect efficiency! (${shotsThisGame} shots)`;
          } else if(excessShots <= 5) {
            efficiencyMsg = `\n‚ö† ${excessShots} excess shots (-${efficiencyPenalty} pts)`;
          } else {
            efficiencyMsg = `\n‚úó ${excessShots} excess shots (-${efficiencyPenalty} pts)`;
          }
          
          const modeText = hemichannelMode ? ' [Hemichannel Mode]' : '';
          alert(`Time's Up!${modeText}${efficiencyMsg}\n\nFinal Score: ${score}`);
        }, 100);
      }
    }

    // -------------------- Main Animation Loop --------------------
    function animate(t=0){ 
      const ts=t*0.001; 
      const dt = Math.min(0.033, lastStamp? ts-lastStamp : 0.016); 
      lastStamp=ts; 
      
      if(!running){ 
        requestAnimationFrame(animate); 
        return; 
      }
      
      // Update timers
      shotTimer = Math.max(0, shotTimer-dt);
      
      // Update game systems
      spawnSpikes(dt);
      spikes.forEach(s=>s.step(dt)); 
      spikes = spikes.filter(s=>!s.dead);
      
      shots.forEach(sh=>sh.step(dt)); 
      shots = shots.filter(s=>!s.dead);
      
      updateGlutamate(dt);
      astrocyte.update(dt);

      // Scoring and game completion
      const exc = excitabilitySum(); 
      score += Math.max(0, Math.floor(5 - exc*0.02)*dt*10);
      
      checkGameComplete(ts);

      // Lose condition tracking
      const meter = document.getElementById('excMeter'); 
      const pct = clamp(exc/EXCIT_THRESH*100,0,100); 
      meter.style.width = Math.min(100,pct)+'%';
      
      if(exc>EXCIT_THRESH) { 
        aboveTime += dt; 
      } else { 
        aboveTime = Math.max(0, aboveTime-dt*0.5); 
      }
      
      if(aboveTime>=LOSE_HOLD){ 
        gameOver(); 
        requestAnimationFrame(animate);
        return;
      }

      // Render everything
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGlutamateBackground(); // Draw glutamate zones first (background)
      drawAxons();
      astrocyte.draw();
      drawSynapses();
      drawSpikes();
      drawShots();

      requestAnimationFrame(animate);
    }

    // -------------------- Drawing Functions --------------------
    function drawGlutamateBackground() {
      if(synapses.length === 0) return;
      
      ctx.save();
      
      // Create glutamate concentration zones with much higher visibility
      synapses.forEach(s => {
        if(s.G > 0.05) { // Show even lower concentrations
          const intensity = clamp(s.G / 6, 0, 1);
          const radius = 30 + intensity * 40; // Larger zones for better visibility
          
          // Create radial gradient for glutamate zone
          const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius);
          
          if(intensity < 0.2) {
            // Low concentration - more visible blue
            gradient.addColorStop(0, `rgba(100, 150, 255, ${0.3 + intensity * 0.4})`);
            gradient.addColorStop(0.7, `rgba(100, 150, 255, ${0.1 + intensity * 0.2})`);
            gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
          } else if(intensity < 0.5) {
            // Medium concentration - prominent purple
            gradient.addColorStop(0, `rgba(200, 100, 255, ${0.4 + intensity * 0.4})`);
            gradient.addColorStop(0.7, `rgba(200, 100, 255, ${0.2 + intensity * 0.3})`);
            gradient.addColorStop(1, 'rgba(200, 100, 255, 0)');
          } else {
            // High concentration - very prominent red
            gradient.addColorStop(0, `rgba(255, 80, 80, ${0.5 + intensity * 0.4})`);
            gradient.addColorStop(0.6, `rgba(255, 80, 80, ${0.3 + intensity * 0.3})`);
            gradient.addColorStop(1, 'rgba(255, 80, 80, 0)');
          }
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Add extra emphasis for very high concentrations
          if(intensity > 0.7) {
            const innerGradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius * 0.4);
            innerGradient.addColorStop(0, `rgba(255, 50, 50, ${intensity * 0.6})`);
            innerGradient.addColorStop(1, 'rgba(255, 50, 50, 0)');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(s.x, s.y, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      ctx.restore();
    }

    function drawAxons(){ 
      ctx.save(); 
      ctx.strokeStyle='#ff6b35'; 
      ctx.lineWidth=3; 
      ctx.lineCap='round';
      ctx.lineJoin='round';
      
      axons.forEach(ax=>{ 
        if(ax.points.length < 2) return;
        
        ctx.beginPath(); 
        ctx.moveTo(ax.points[0].x, ax.points[0].y);
        
        // Use quadratic curves for smooth appearance
        for(let i = 1; i < ax.points.length - 1; i++) {
          const current = ax.points[i];
          const next = ax.points[i + 1];
          const midX = (current.x + next.x) / 2;
          const midY = (current.y + next.y) / 2;
          
          ctx.quadraticCurveTo(current.x, current.y, midX, midY);
        }
        
        // Draw to the final point
        const lastPoint = ax.points[ax.points.length - 1];
        ctx.lineTo(lastPoint.x, lastPoint.y);
        
        ctx.stroke(); 
      }); 
      ctx.restore(); 
    }
    
    function drawSpikes(){ 
      ctx.save(); 
      spikes.forEach(s=>{ 
        const p=s.pos; 
        const speed = s.speed / SPIKE_SPEED; // Normalize speed for visual effect
        
        // Color based on speed - faster spikes are more dangerous
        if(speed > 1.1) {
          ctx.fillStyle='#ff4444'; // Fast spikes are red
        } else if(speed > 0.95) {
          ctx.fillStyle='#ffaa44'; // Medium spikes are orange  
        } else {
          ctx.fillStyle='#ffffff'; // Slow spikes are white
        }
        
        const size = 2 + speed * 2; // Size indicates speed
        ctx.beginPath(); 
        ctx.arc(p.x,p.y,size,0,Math.PI*2); 
        ctx.fill(); 
        
        // Add trailing effect for fast spikes
        if(speed > 1.05) {
          ctx.globalAlpha = 0.3;
          const trail = s.axon.posAt(Math.max(0, s.u - 0.02));
          ctx.beginPath(); 
          ctx.arc(trail.x,trail.y,size*0.7,0,Math.PI*2); 
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }); 
      ctx.restore(); 
    }
    
    function drawSynapses(){ 
      synapses.forEach(s=>s.draw()); 
    }
    
    function drawShots(){ 
      shots.forEach(s=>s.draw()); 
    }

    // -------------------- World Initialization --------------------
    function generateWorld(){ 
      astrocyte = new AstrocyteStructure(canvas.width/2, canvas.height/2, 120); 
      generateAxonField(); 
      renderBoard(); 
    }

    // -------------------- UI Event Handlers --------------------
    document.getElementById('startBtn').addEventListener('click', ()=>{ 
      if(!running){ 
        startGame(); 
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', resetAll);
    
    document.getElementById('hemichannelToggle').addEventListener('change', (e) => {
      hemichannelMode = e.target.checked;
    });
    
    document.getElementById('saveScoreBtn').addEventListener('click', ()=>{ 
      const name=(document.getElementById('playerName').value||'Player').trim().slice(0,16); 
      const suffix = hemichannelMode ? ' [HC]' : '';
      addScore(name + suffix, Math.floor(score)); 
    });
    
    document.getElementById('clearBoardBtn').addEventListener('click', clearBoard);

    // -------------------- Canvas Management --------------------
    function resizeCanvas(){ 
      const area=document.querySelector('.simulation-area'); 
      const newWidth = area.clientWidth;
      const newHeight = area.clientHeight;
      
      // Only regenerate if size actually changed significantly
      if(Math.abs(canvas.width - newWidth) > 10 || Math.abs(canvas.height - newHeight) > 10) {
        canvas.width = newWidth; 
        canvas.height = newHeight; 
        generateWorld(); 
      }
    }

    // -------------------- Initialization --------------------
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', ()=>{ 
      resizeCanvas(); 
      updateHUD(); 
      requestAnimationFrame(animate); 
    });
  </script>
</body>
</html>